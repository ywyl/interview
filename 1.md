# 12月面试题

## 12.4

1. 谈谈你对MVVM的理解。 <br />
MVVM 中 M 是指 Model，即最原始的数据（一般从接口中请求过来的），V 是指 View 层，泛指界面DOM元素，VM 指 ViewModel，位于二者中间，是他们的桥梁，将原始数据和视图进行关联（vue 框架所做的事，监听数据，更新 DOM）

2. slot是什么？有什么作用？原理是什么？ <br />
slot是插槽，是 vue 的内容分发机制，组件使用 slot 作为承载分发内容时的出口。组件在被调用的时候可以由调用它的父组件来确定具体显示什么内容。分为匿名插槽和具名插槽（name 属性）。作用域插槽，父组件可以给子组件传递参数。 <br />
原理：当子组件实例化时，获取到父组件传入的 slot 标签的内容，放在一个全局对象中，通过 name 区分。渲染的时候，遇到 slot 标签，使用对象中的内容进行替换（同时可以传必要的数据）

3. assets 和 static 的区别。 <br />
相同点：二者都是用来存放静态资源的（图片，字体图标，样式等）； <br />
不同点：assets 存放的文件会压缩打包，static 的不会压缩，而是直接放到服务器。后者效率更高但是占据的空间更大，空间换时间； <br />
建议：template 中需要的 js 和样式放在 assets 中；引入的三方资源字体图标等放在 static，这些已经是处理过的。

4. vue 的模板编译的原理。 <br />
模板编译的主要目的是将 template 转化成为一个渲染函数（h 函数）。分为解析、优化和生成 3 个阶段 <br />
解析阶段（parse）：将 template 转化成抽象语法书 AST，主要是通过正则表达式； <br />
优化阶段（optimize）：遍历 AST，标记静态节点，在 diff 比较时，跳过这些节点，避免重复渲染； <br />
生成阶段（generate）：将 AST 转化为渲染函数。

5. v-for 和 v-if 的优先级 <br />
vue2 中 v-for 的优先级高，vue3 则是 v-if 高，使用时需要灵活运用。vue2 可能会做一些无效的遍历（遍历到了不需要渲染），vue3 则是有些项会无法遍历到。

## 12.5

1. 前端路由 hash 和 history。 <br />
hash: 将前端路由的路径用 # 号拼接在真实的 url 后面，通过更新锚点 # 来更新页面。# 号后面的路径发生变化时并不会发起真正的请求，而是触发 onhashchange 事件。页面跳转是在客户端进行的，所以不利于 SEO； <br />
history：允许开发者直接更改前端路由，更新浏览器 url 但是不重新发起请求。通过 pushState 和 replaceState 实现无刷新跳转的功能； <br />
history 刷新页面时会触发请求，会将整个 url 传给后端，匹配不到时就会出现 404，hash 不会，因为 # 后面的内容不会发送给后端

2. 计算属性和 watch 有什么区别？ <br />
计算属性：依赖其他值，computed 的值有缓存，只有依赖项发生变化时才会重新计算； <br />
watch：更多是起一个监听的作用，当某些值变化时，做一些操作，比如异步操作和开销较大的操作时

3. 组件之间的通信方式。 <br />
+ 父传子：通过属性绑定到子组件，子组件通过 props 拿到
+ 子传父：通过 emit 事件将数据传给父组件
+ ref 方式，父组件拿到子组件的整个实例
+ 子组件主动暴露，expose
+ attrs，包含父组件引用子组件时绑定的属性中未在 props 声明的
+ 依赖注入（provide/inject）
+ 全局状态管理 Pinia

4. vue 中父子组件生命周期的执行顺序。 <br />
加载渲染：父 beforeCreated -> 父 created -> 父 beforeMounted -> 子 beforeCreated -> 子 created -> 子 beforeMounted -> 子 mounted -> 父 mounted； <br />
子组件更新：父 beforeUpdated -> 子 beforeUpdated -> 子 updated -> 父 updated； <br />
父组件更新：父 beforeUpdated -> 父 updated； <br />
销毁：父 beforeDestroy -> 子 beforeDestroy -> 子 destroyed -> 父 destroyed。

5. Keep-alive。 <br />
keep-alive 可以缓存组件，在组件的切换过程中将状态保存在内存中，防止重复渲染 DOM。使用 Keep-alive 包裹后会多出两个生命周期 deactivated 和 activated，beforeDestroyed 和 destroyed 则不再触发

## 12.6

1. webpack 的构建流程。 <br />
webpack 启动后，从 entry 开始，递归解析 entry 依赖的所有 module，找到每个 module.rules 里配置的 loader 进行相应的转换处理。将 module 转换后，解析各个 module 依赖的其它的一些模块，解析的结果是一个一个 chunk，最后 webpack 会将所有的 chunk 转换成 js，在整个构建的过程中，webpack 会执行 plugin 当中的插件，完成 plugin 的任务  <br />
+ entry：模块入口、使得源文件加入到构建流程中
+ output：配置如何输出最终的文件夹
+ module：配置各种类型文件的处理规则
+ plugin：配置扩展插件
+ devServer：实现本地服务，包括 http、热更新、source map 等服务

2. 如何检测数据类型？ <br />
typeof：数组、对象和 null 会判断成 object
instanceof: 只能判断引用数据类型，不能判断基本数据类型。A 的 __proto__ 指向 B 的 prototype，则为真，原型链的上的也算
Object.prototype.toString.call()：精确判断

3. 闭包。 <br />
通过闭包可以在函数的外部读取函数内部的变量。其做法就是函数本身返回的就是一个函数，通过这个返回的函数可以将函数里面的变量暴露出去 <br />
好处：读取函数内部变量，封装对象的私有属性和方法，模拟块级作用域。坏处：占内存

4. 函数的柯里化。 <br />
表现形式：将函数 f(a, b, c) 转化成 f(a)(b)(c)；柯里化不会调用函数，它只是对函数进行转化
```js
function curry(f) {
	return function(a) {
		return function(b) {
			return f(a, b);
		}
	}
}
```
好处：会保持原函数仍然能被调用，但是参数不足时，则返回部分用于函数。可以简化函数

5. new的时候发生了什么？ <br />
首先会创建一个空对象； <br />
将该对象的 __proto__ 指向构造函数的 prototype； <br />
将构造函数的 this 指向该对象，执行构造函数的代码（为这个对象添加属性）； <br />
判断返回的值类型，值类型则返回创建的对象，引用类型返回这个引用类型的对象